# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

  **Ответ:**
- получение списка операций по БД *dbname*
```
db.currentOp(
   {
     "active" : true,
     "numYields" : 0,
     "waitingForLock" : false,
     "ns" : /^dbname\./
   }
)
```

- остановка запроса пользователя по opId, который получим в резльтате предыдущего запроса (но нужно быть внимательным),_
  чтобы не убить служебные длительные запросы, связанные например с репликацией данных.
```
db.killOp(<opId>)
```

- вариант решения проблемы с долгими (зависающими) запросами

```
Включить логгирование длительных запросов.
Использовать explain, для анализа запросов.
Проанализировать запросы на использование индексов, естьони или нет. Используются ли индексы в запросах._
Возможно используются не те индексы, попробовать  использовать cursor.hint(), чтобы переопределить выбор индекса по умолчанию.
Обратить внимание на запросы с большими значениями docsExamined, что может говорить о неэффективности используемых индексов.
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
  **Ответ:**
```
Если в базе данных много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% от текущей совокупности_
 ключей с установленным сроком действия , Redis может заблокировать их, чтобы снизить процент ключей, срок действия которых уже истек.

Этот подход необходим, чтобы избежать использования слишком большого количества памяти для ключей, срок действия которых уже истек.

Таким образом, причина блокировки операции записи в том, что количество ключей, TTL которых истекает в одно и то же время, больше 25%.
```

 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

  **Ответ:**
```
  1. Если ошибка возникает часто, то это могут быть проблемы с сетью.
  2. Также, ошибка может появляться, когда в рамках одного или нескольких запросов отправляются миллионы строк. В этом случае можно попробовать увеличить net_read_timeout с 30 секунд по умолчанию до 60 секунд или более,_
     необходимых для выполнения запроса или запросов.
  3. Реже эта ошибка может возникать, когда клиент пытается установить начальное соединение с сервером. Если значение connect_timeout установлено всего на несколько секунд, можно попробовать его увеличить. Актально для_
     медленных соединений. Определить что причина в этом можно используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. Он увеличивается на единицу для каждой начальной попытки соединения, которую сервер прерывает.
  4. Если причина не что-то выше перечисленное, возможно, возникла проблема со значениями BLOB, превышающими max_allowed_packet. При этой причине ошибка InterfaceError может сопровождаться ошибкой ER_NET_PACKET_TOO_LARGE._
     В этом случае нужно увеличить max_allowed_packet.
```

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

  **Ответ:**
```
oom-killer - это Out-Of-Memory killer процесс, который завершает приложение, чтобы спасти ядро от сбоя.
При этом он вызывается когда физическая память и пространство подкачки исчерпаны.
Решение - это увеличитьь объем памяти на сервере, где запущен Postgre SQL.
Также, Linux может резервировать больше памяти для процессов, чем ее есть, но фактически ее не выделять. За это отвечает переменная vm.overcommit_memory.
При установке значения vm.overcommit_memory = 2 , ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio.
На OOM-Killer влияет еще один элемент — возможность подкачки, которой управляет переменная /proc/sys/vm/swappiness.
Эти значения указывают ядру, как обрабатывать подкачку страниц.
Чем больше ее значение, тем меньше вероятность, что OOM-Killer завершит процесс, но из-за операций ввода-вывода это негативно сказывается на базе данных.
По-умолчанию значение равно 60, но если вся база помещается в памяти, рекомендуется устанавливать ее в 1.
```

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---

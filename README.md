 devops-netology

# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"
##       1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
            Если воспользоваться командой '''type -a cd''', то мы увидим что команда cd является встроенной командой оболочки. 
            Эта клманда встроенная, так как она меняет текущую папку только для оболочки, в которой выполняется.

##       2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
             ''' cat <some_file>| grep <some_string> | wc -l '''
          
##       3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
             Это процесс systemd
             ''' vagrant@vagrant:~/devops-netology$ pstree -p
                 systemd(1)─┬─VBoxService(770)─┬─{VBoxService}(772)
                            │                  ├─{VBoxService}(773)
                            │                  ├─{VBoxService}(774)
                            │                  ├─{VBoxService}(775)
                            │                  ├─{VBoxService}(778)
                            │                  ├─{VBoxService}(779)
                            │                  ├─{VBoxService}(780)
                            │                  └─{VBoxService}(781)
                            ├─accounts-daemon(587)─┬─{accounts-daemon}(601)
                            │                      └─{accounts-daemon}(633)
                            ├─agetty(811) '''

##       4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
             '''sudo ls -z 2>/dev/pts/1''' 

##       5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
             Да, получится. В приведенном ниже примере команде cat на stdin передается файл myfile_1 и stdout записывается в файл myfile_2
             '''sudo cat < myfile_1 >> myfile_2'''

##       6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
             Да, получится и мы сможем наблюдать выводимые данные. PTY состоит из двух виртуальных устройств PTY master (PTM) и PTY slave (PTS).
             В свою очередь PTS является TTY устройством. PTS устройство находится по пути /dev/pts/N и вызвав ,например, команду '''echo "12345" > /dev/pts/N'''
             мы передадим данные в терминал N.  

##       7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
             '''bash 5>&1''' запустит bash, создает 5-й дексриптор и перенаправляет его в stdout. Если следом мы выполним '''echo 'netology' > /proc/$$/fd/5''',
             то в на экран в консоль выведется слово '''netology'''. Это произойдет, потому что в запущенном bash 5-й дескриптор, в который выводится результат команды
             '''echo 'netology' ''', перенаправлен в stdout. $$ - обозначает, что мы обращаемся к PID нашего shell, в подкаталоге fd хранятся записи на каждый файл, который 
             открыт процессом. Имя записи является символьной ссылкой на реальный файл и соостветсвует номеру дескриптора. В данном случае дескриптор 5.

##       8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? 
##          Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. 
##          Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.    
             Ответ в вопросе. Получится, если поменять местами stdout и stderr.
             Выполнив команду '''bash 3>&1 1>&2 2>&3 3>&-''' мы запустим bash в котором дескрипторы stdout и stderr будут поменяны местами, через pipe в stdin будет передаваться уже stderr.
             Последняя команда '''3>&-''' закроет файловый дескриптор 3, так как он больше не нужен.  

##       9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
             Команда выводит переменные оболочки. $$ обозначает, что мы обращаемся к PID shell.
             Аналогичный по содержанию вывод, но выводящий все перменные окружения можно получить используя команды '''printenv''' и '''env'''
             Так же можно воспользоваться командой '''set''', но без ключей она выведет все перменные консольной оболочки, переменные окружения, локальные переменные и тд.

##      10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
             *cmdline*
             Файл cmdline содержит полную командную строку запуска процесса, кроме тех процессов что стали зомби.
             В этом слйчае в файле ничего нет, то есть чтение этого файла вернет 0 символов. Аргументы командной строки в этом файле указаны как список строк,
             каждая из которых завешается нулевым символом, с добавочным нулевым байтом после последней строки.
             *exe*
             Под Linux 2.2 и 2.4 exe является символьной ссылкой, содержащей фактический путь к исполняемой команде. Символьная ссылка exe может использоваться обычным образом - при попытке открыть 
             exe будет открыт исполняемый файл. Вы можете даже ввести /proc/[pid]/exe чтобы запустить другую копию процесса такого же как и процесс с номером [pid].
             Под Linux 2.0 и в более ранних версиях exe является указателем на исполняемый файл и является символьной ссылкой. Вызов Readlink(2) на этот специальный файл exe под Linux 2.0
             и более ранних версий возвращает строку формата: [устройство]:индексный_дескриптор
             Например, строка [0301]:1502 означает индексный дескриптор 1502 на главном устройстве 03 (IDE, MFM и т. д.) и второстепенном устройстве 01 (первый раздел на первом диске).
             Для того, чтобы найти этот файл, может быть использована команда find(1) с опцией -inum.

##      11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
             '''vagrant@vagrant:~/devops-netology$ cat /proc/cpuinfo | grep flags | uniq
             flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid 
                               tsc_known_freq pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm invpcid_single pti fsgsbase avx2 invpcid md_clear flush_l1d'''
             По выводу данных команды *cat /proc/cpuinfo | grep flags | uniq* видно, что старшая версия набора инструкций SSE поддерживаемая процессором - это SSE4_2

##      12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
##          vagrant@netology1:~$ ssh localhost 'tty'
##          not a tty
##          Почитайте, почему так происходит, и как изменить поведение.
             При создании новой сесси по ssh не выделяется псевдотерминал, для выделения нового псевдотерминала нужно использовать ключ -t '''ssh -t localhost 'tty' '''
 
##      13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. 
##          Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
             Делал по мануалу из README.md c github.
             ''' vagrant@vagrant:~/devops-netology$ history
                     664  top
                     665  jobs -l
                     666  bg
                     667  jobs -l
                     668  disown top
                     669  screen -x '''
            Но дальше при вводе ''' reptyr 2099 ''' получал ошибку *[-] Unable to open the tty in the child*.
            Изменение 1 на 0 в файле /proc/sys/kernel/yama/ptrace_scope тоже не помогло.
            Получилось только с использованием ключа -L, в итоге смог перенсти процесс top в screen следующей командой ''' reptyr -L 2099 '''

##      14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а,
##          который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file.
##          Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать
            В первой конструкции команда *echo* выполняется с повышенными правами, а результат перенаправляется с правами обычного пльзователя. Команда
            *tee* по-умолчанию принимает данные stdin и выводит их в stdout и в файл. Сооствественно, если выполнить ее от root, то файл перезапишется.
